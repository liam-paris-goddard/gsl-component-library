/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { NavigationItem } from "./interfaces/header-link";
export { NavigationItem } from "./interfaces/header-link";
export namespace Components {
    interface GslHeader {
        /**
          * Aria label when nav is open
         */
        "buttonLabelActive": string;
        /**
          * Aria label when nav is closed
         */
        "buttonLabelInactive": string;
        /**
          * Optional alt text for the default logo
         */
        "logoAlt": string;
        /**
          * Link the logo should direct to
         */
        "logoHref": string;
        /**
          * path to logo asset
         */
        "logoSrc": string;
        /**
          * controlled by the shell component, expanded state of side nav, to set the state of the toggle button
         */
        "navExpanded": boolean;
        /**
          * Page title
         */
        "pageTitle"?: string;
        /**
          * The id of the side–nav element so aria‑controls can target it
         */
        "sideNavId": string;
    }
    interface GslShell {
        "currentPath": string;
        "logoSrc": string;
        "navigationData": NavigationItem[];
        "pageTitle": string;
    }
    interface GslSideNav {
        /**
          * String that will open the nav's submenus to the link specified. currently will be used on route navigation. only works with nav links that have hrefs
         */
        "currentPath": string;
        /**
          * expanded state of side nav, controlled by shell component
         */
        "isExpanded": boolean;
        /**
          * Controlled by shell component, will persist the expanded state on route navigation or reload
         */
        "locked": boolean;
        /**
          * Navigation data structure, including nested links and "new/featured" section
         */
        "navigationData": NavigationItem[];
    }
}
export interface GslHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGslHeaderElement;
}
export interface GslShellCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGslShellElement;
}
export interface GslSideNavCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGslSideNavElement;
}
declare global {
    interface HTMLGslHeaderElementEventMap {
        "gsl:toggle-side-nav": boolean;
    }
    interface HTMLGslHeaderElement extends Components.GslHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGslHeaderElementEventMap>(type: K, listener: (this: HTMLGslHeaderElement, ev: GslHeaderCustomEvent<HTMLGslHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGslHeaderElementEventMap>(type: K, listener: (this: HTMLGslHeaderElement, ev: GslHeaderCustomEvent<HTMLGslHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGslHeaderElement: {
        prototype: HTMLGslHeaderElement;
        new (): HTMLGslHeaderElement;
    };
    interface HTMLGslShellElementEventMap {
        "gslToggleSidenav": { expanded: boolean, source: 'header' | 'side-nav' };
        "gslToggleLock": { locked: boolean, source: 'header' | 'side-nav' };
    }
    interface HTMLGslShellElement extends Components.GslShell, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGslShellElementEventMap>(type: K, listener: (this: HTMLGslShellElement, ev: GslShellCustomEvent<HTMLGslShellElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGslShellElementEventMap>(type: K, listener: (this: HTMLGslShellElement, ev: GslShellCustomEvent<HTMLGslShellElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGslShellElement: {
        prototype: HTMLGslShellElement;
        new (): HTMLGslShellElement;
    };
    interface HTMLGslSideNavElementEventMap {
        "gslNavigate": { href: string };
    }
    interface HTMLGslSideNavElement extends Components.GslSideNav, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGslSideNavElementEventMap>(type: K, listener: (this: HTMLGslSideNavElement, ev: GslSideNavCustomEvent<HTMLGslSideNavElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGslSideNavElementEventMap>(type: K, listener: (this: HTMLGslSideNavElement, ev: GslSideNavCustomEvent<HTMLGslSideNavElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGslSideNavElement: {
        prototype: HTMLGslSideNavElement;
        new (): HTMLGslSideNavElement;
    };
    interface HTMLElementTagNameMap {
        "gsl-header": HTMLGslHeaderElement;
        "gsl-shell": HTMLGslShellElement;
        "gsl-side-nav": HTMLGslSideNavElement;
    }
}
declare namespace LocalJSX {
    interface GslHeader {
        /**
          * Aria label when nav is open
         */
        "buttonLabelActive"?: string;
        /**
          * Aria label when nav is closed
         */
        "buttonLabelInactive"?: string;
        /**
          * Optional alt text for the default logo
         */
        "logoAlt"?: string;
        /**
          * Link the logo should direct to
         */
        "logoHref"?: string;
        /**
          * path to logo asset
         */
        "logoSrc"?: string;
        /**
          * controlled by the shell component, expanded state of side nav, to set the state of the toggle button
         */
        "navExpanded"?: boolean;
        /**
          * Emitted when menuButton is toggled
         */
        "onGsl:toggle-side-nav"?: (event: GslHeaderCustomEvent<boolean>) => void;
        /**
          * Page title
         */
        "pageTitle"?: string;
        /**
          * The id of the side–nav element so aria‑controls can target it
         */
        "sideNavId"?: string;
    }
    interface GslShell {
        "currentPath"?: string;
        "logoSrc"?: string;
        "navigationData"?: NavigationItem[];
        "onGslToggleLock"?: (event: GslShellCustomEvent<{ locked: boolean, source: 'header' | 'side-nav' }>) => void;
        "onGslToggleSidenav"?: (event: GslShellCustomEvent<{ expanded: boolean, source: 'header' | 'side-nav' }>) => void;
        "pageTitle"?: string;
    }
    interface GslSideNav {
        /**
          * String that will open the nav's submenus to the link specified. currently will be used on route navigation. only works with nav links that have hrefs
         */
        "currentPath"?: string;
        /**
          * expanded state of side nav, controlled by shell component
         */
        "isExpanded"?: boolean;
        /**
          * Controlled by shell component, will persist the expanded state on route navigation or reload
         */
        "locked"?: boolean;
        /**
          * Navigation data structure, including nested links and "new/featured" section
         */
        "navigationData"?: NavigationItem[];
        "onGslNavigate"?: (event: GslSideNavCustomEvent<{ href: string }>) => void;
    }
    interface IntrinsicElements {
        "gsl-header": GslHeader;
        "gsl-shell": GslShell;
        "gsl-side-nav": GslSideNav;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "gsl-header": LocalJSX.GslHeader & JSXBase.HTMLAttributes<HTMLGslHeaderElement>;
            "gsl-shell": LocalJSX.GslShell & JSXBase.HTMLAttributes<HTMLGslShellElement>;
            "gsl-side-nav": LocalJSX.GslSideNav & JSXBase.HTMLAttributes<HTMLGslSideNavElement>;
        }
    }
}
